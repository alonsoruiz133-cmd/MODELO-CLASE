<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Movimiento 3D con Teclado — Three.js (FBX)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body,html { margin:0; height:100%; overflow:hidden; background:#111; color:#eee; font-family:sans-serif; }
    #info {
      position:absolute; top:10px; left:10px; z-index:10;
      background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:6px;
      font-size:13px;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="info">W/A/S/D — Mueve el modelo | Shift — Correr</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@latest/build/three.module.js';
    import { FBXLoader } from 'https://unpkg.com/three@latest/examples/jsm/loaders/FBXLoader.js';
    import { OrbitControls } from 'https://unpkg.com/three@latest/examples/jsm/controls/OrbitControls.js';

    // --- ESCENA ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x20232a);

    // --- CAMARA ---
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 10);

    // --- RENDERER ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- LUCES ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7.5);
    dir.castShadow = true;
    scene.add(dir);

    // --- PLANO (suelo) ---
    const planeGeo = new THREE.PlaneGeometry(100, 100);
    const planeMat = new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 1 });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // --- CONTROLES ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.5, 0);
    controls.update();

    // --- VARIABLES ---
    const loader = new FBXLoader();
    let model, mixer;
    const actions = {};
    let activeAction;

    // --- FUNCION PARA CAMBIAR ANIMACION ---
    function setAction(name) {
      if (activeAction === actions[name]) return;
      if (activeAction) activeAction.fadeOut(0.3);
      activeAction = actions[name];
      if (activeAction) activeAction.reset().fadeIn(0.3).play();
    }

    // --- CARGA DE MODELOS ---
    loader.load('models/Idle.fbx', (fbx) => {
      model = fbx;
      model.scale.setScalar(0.01); // ajusta según tamaño
      model.traverse(c => { if (c.isMesh) c.castShadow = true; });
      scene.add(model);

      mixer = new THREE.AnimationMixer(model);
      actions.idle = mixer.clipAction(fbx.animations[0]);
      actions.idle.play();

      // Cargar las demás animaciones
      loader.load('models/Walking .fbx', (walk) => {
        actions.walk = mixer.clipAction(walk.animations[0]);
      });

      loader.load('models/RunningArc.fbx', (run) => {
        actions.run = mixer.clipAction(run.animations[0]);
      });
    });

    // --- MOVIMIENTO ---
    const keys = { forward:false, back:false, left:false, right:false, shift:false };
    window.addEventListener('keydown', (e) => {
      switch(e.code){
        case 'KeyW': case 'ArrowUp': keys.forward = true; break;
        case 'KeyS': case 'ArrowDown': keys.back = true; break;
        case 'KeyA': case 'ArrowLeft': keys.left = true; break;
        case 'KeyD': case 'ArrowRight': keys.right = true; break;
        case 'ShiftLeft': case 'ShiftRight': keys.shift = true; break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch(e.code){
        case 'KeyW': case 'ArrowUp': keys.forward = false; break;
        case 'KeyS': case 'ArrowDown': keys.back = false; break;
        case 'KeyA': case 'ArrowLeft': keys.left = false; break;
        case 'KeyD': case 'ArrowRight': keys.right = false; break;
        case 'ShiftLeft': case 'ShiftRight': keys.shift = false; break;
      }
    });

    // --- ANIMACION PRINCIPAL ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (mixer) mixer.update(delta);

      if (model) {
        const speed = keys.shift ? 10 : 5;
        const move = new THREE.Vector3();

        if (keys.forward) move.z -= 1;
        if (keys.back) move.z += 1;
        if (keys.left) move.x -= 1;
        if (keys.right) move.x += 1;

        if (move.lengthSq() > 0) {
          move.normalize().multiplyScalar(speed * delta);
          model.position.add(move);
          model.lookAt(model.position.x - move.x, model.position.y, model.position.z - move.z);
          if (keys.shift) setAction('run');
          else setAction('walk');
        } else {
          setAction('idle');
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>







